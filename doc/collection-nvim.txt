*collection-nvim.txt*
A collection of configurations to implement some of neovim's built in
features.


CONTENTS                                                     *collection-nvim*

    0. Prerequisites ........... |collection-prerequisites|
    1. Features ................ |collection-features|
    2. Options ................. |collection-options|


==============================================================================
PREREQUISITES                                       *collection-prerequisites*

- Neovim 0.5


==============================================================================
FEATURES                                                 *collection-features*

    0. Snippet managing ................ |collection-snippets|
    1. Asynchronous program running .... |collection-run-program|
    2. Filetype specific settings ...... |collection-filetypes|
    3. .config.vim ....................... |collection-config-file|
    4. Code formatting ................. |collection-formatting|
    5. Toggling Terminal ............... |collection-terminal|


==============================================================================
OPTIONS                                                   *collection-options*

g:collection_errorlist_type                      *g:collection_errorlist_type*

	Type of window to be used when toggling an errorlist. Set this value 
	to 1 to use normal bottom split instead of vertical split.

        default value: 0

g:collection_errorlist_size                      *g:collection_errorlist_size*

	Window size to be used for errorlist when toggling. 
	Size can be set between 1 and 200.

        default value: 50

g:collection_format_ignore                        *g:collection_format_ignore*

	List of comma separated filetypes that won't be formated.

        default value: "text,netrw,markdown"

g:collection_format_save                            *g:collection_format_save*

	Changing value of this option to 0 will disable saving the file when
	formatting. 
	To automatically format on save, you can add your format key to a
	BufWritePre event.

        default value: 1

g:collection_terminal_type                        *g:collection_terminal_type*

	Type of terminal to be used when toggling. Set this value to 1 to
	use normal bottom split terminal instead of vertical split.

        default value: 0

g:collection_terminal_size                        *g:collection_terminal_size*

	Window size to be used for terminal when toggling. 
	Size can be set between 1 and 200.

        default value: 50

g:collection_additional_config                *g:collection_additional_config*

	Enable or disable additional project specific config with
	|.config.vim|.

	default value: 1

g:collection_config_file                            *g:collection_config_file*

	Name of the additional config file.

	default value: '.config.vim'

==============================================================================
CONFIGURING FILETYPES                                   *collection-filetypes*
                                                                 *.config.vim*

Set up compilers, interpreters, executions and formaters for each filetype.
See |collection-config-file|.

Options for compiler and interpreter should start with interpreter or compiler
name and then path and additional option. 

Paths should be given unexpanded ( see expand ). You can change the
extension of the path with {unexpanded-path}.{extension}. 
For example if you want to compile the program into a file with a 
different extension and then run that file.

Example: 
    Expanding `%:p` may result to `/path/file.ts`.
    You can then remove extension with `:r` and add a new one with `.js`.
    Therefore `%:p:r.js` will result to `/path/file.js`.


1. Interpreter                              *collection-filetypes-interpreter*

	To add an interpreter you can add code following the examples to 
	your init.vim:
>
	let g:collection_python_interpreter="python3 %:p"
	let g:collection_javascript_interpreter="node %:p"
<
	If interpreter is set, the program will ignore the compiler and	
	execute option.

2. Compiler                                    *collection-filetypes-compiler*

	To add a compiler, you can follow these examples:
>
	let g:collection_java_compiler="javac %:p"
	let g:collection_c_compiler="gcc %:p -o %:p:r -Wall"
	let g:collection_cs_compiler="csc %:p"
<
3. Execute                                     *collection-filetypes-execute*

	Execute options will be run immediately after successful compiling.
	Examples:
>
	let g:collection_java_execute="java %:p"
	let g:collection_c_execute="%:p:r"
	let g:collection_cs_execute="mono %:p:r.exe"
<
3. Formater                                    *collection-filetypes-formater*

	Formater to be used for the filetype when formatting the file. If
	no option is provided, default indenting will be used.

	Examples:
>
	let g:collection_python_formater="autopep8 %"
	let g:collection_typescript_formater="prettier --use tabs %"
<
	The value of the formater option should start with the name of
	the formater and continue with paths and additional settings.
	Normally adding '%' as a path will suffice.

==============================================================================
ADDING A JSON FILE                                    *collection-config-file*
	
	If you want to use different comping or formating in a project, you
	can add a |.config.vim| file. 

	Example .config.vim:
>
	let g:collection_typescript_compiler = "tsc --project tsconfig.json"
	let g:collection_typescript_formater = "prettier %"
	unlet g:collection_typescript_execute


==============================================================================
SNIPPETS                                                 *collection-snippets*
    
	List all availible snippets:
	`:lua require('collection').snippets('')`

	Create a new snippet:
	`:lua require('collection').snippets({snippet-name})`

	When creating a snippet, you need to provide a name and key binding.
	Optionally you can add where to move the cursor after pasting the
	snippet.
	Example snippet creation:
>
	Name: mainClass.java
	Key mapping: <leader>jm
	Move cursor: 2w
	Code:
	public class x {
	    public static void main(String[] args)
	}
<
	Snippets can be either pasted directly from the list, or with a
	remaping of the keys you specified when creating them. To enable
	the mappings, use:
	`:lua require('collection').snippets('load')` .
	You can use an autocomand to load them on entering vim.
>
	autocmd VimEnter * lua require('collection').snippets('load')
<
	Recommended remappings:	

	`command! -nargs=* Sn lua require('collection').snippets(<q-args>)`

==============================================================================
RUNNING PROGRAM                                       *collection-run-program*

	Run the program with:
	`:lua require('collection').runProgram({arguments})`

	For each filetype you can set an interpreter, a compiler and an
	execute. You cannot have both a compiler and an interpreter.
	If execution is specified, the program will execute it after 
	successful compiling.

	Optional arguments can be added to the command. Arguments tarting with
	'-' will be used when compiling, others when executing.

	Program output can be toggled with:
	`:lua require('collection').toggleErrorlist()`
	See |collection-options|.

	All compilers and interpreters need to be installed on your computer.
	See |collection-filetypes| and |collection-config-file| for more on 
	configuring filetype-specific and project-specific settings.

	Recommended remappings:

	`command! -nargs=* R lua require('collection').runProgram(<q-args>)`
	`map <C-e> <cmd>lua require('collection').toggleErrorlist()<CR>`

==============================================================================
CODE FORMATING                                         *collection-formatting*

	Format the code with:
	`:lua require('collection').format()`

	You can set up different formaters for different filetypes, but they
	need to be manually installed on the computer. If formater is not
	specified or cannot be executed, default indenting will be used.

	See |collection-filetypes-formaters| and |collection-options| 
	for more on setting up formaters.

	You can map the command to a more conventien key binding. As an
	example:
>
	nnoremap <leader>f :lua require('collection').format()<CR>
<

==============================================================================
TOGGLING TERMINAL                                        *collection-terminal*

	Toggle the terminal with:
	`:lua require('collection').toggleTerminal()`

	Terminal keeps the same 
	instance when toggled off, the process is not killed. See
	|collection-options| for more on configuring the terminal.

	Mapping is recomended:
>
	nnoremap <F4> :lua require('collection').toggleTerminal<CR>
	tnoremap <F4> <C-\><c-n>:lua require('collection').toggleTerminal<CR>
>

==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet:fen:noet:
